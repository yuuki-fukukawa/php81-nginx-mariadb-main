{
  "version": 3,
  "sources": ["../src/server.ts"],
  "sourcesContent": ["import { createServer, IncomingMessage } from 'http'\nimport * as process from 'process'\nimport { InertiaAppResponse, Page } from './types'\nimport cluster from 'node:cluster';\nimport { availableParallelism } from 'node:os';\n\ntype AppCallback = (page: Page) => InertiaAppResponse\ntype RouteHandler = (request: IncomingMessage) => Promise<unknown>\ntype ServerOptions = {\n  port?: number\n  cluster?: boolean\n}\ntype Port = number\n\nconst readableToString: (readable: IncomingMessage) => Promise<string> = (readable) =>\n  new Promise((resolve, reject) => {\n    let data = ''\n    readable.on('data', (chunk) => (data += chunk))\n    readable.on('end', () => resolve(data))\n    readable.on('error', (err) => reject(err))\n  })\n\nexport default (render: AppCallback, options?: Port | ServerOptions): void => {\n  const _port = typeof options === 'number' ? options : options?.port ?? 13714;\n  const _useCluster = typeof options === 'object' && options?.cluster !== undefined ? options.cluster : false;\n\n  const log = (message: string) => {\n    console.log(_useCluster && !cluster.isPrimary ? `[${cluster.worker?.id ?? 'N/A'} / ${cluster.worker?.process?.pid ?? 'N/A'}] ${message}` : message)\n  }\n\n  if (_useCluster && cluster.isPrimary) {\n    log('Primary Inertia SSR server process started...')\n\n    for (let i = 0; i < availableParallelism(); i++) {\n      cluster.fork()\n    }\n\n    return\n  }\n\n  const routes: Record<string, RouteHandler> = {\n    '/health': async () => ({ status: 'OK', timestamp: Date.now() }),\n    '/shutdown': () => process.exit(),\n    '/render': async (request) => render(JSON.parse(await readableToString(request))),\n    '/404': async () => ({ status: 'NOT_FOUND', timestamp: Date.now() }),\n  }\n\n  createServer(async (request, response) => {\n    const dispatchRoute = routes[<string>request.url] || routes['/404']\n\n    try {\n      response.writeHead(200, { 'Content-Type': 'application/json', Server: 'Inertia.js SSR' })\n      response.write(JSON.stringify(await dispatchRoute(request)))\n    } catch (e) {\n      console.error(e)\n    }\n\n    response.end()\n  }).listen(_port, () => log('Inertia SSR server started.'))\n\n  log(`Starting SSR server on port ${_port}...`)\n}\n"],
  "mappings": "AAAA,OAAS,gBAAAA,MAAqC,OAC9C,UAAYC,MAAa,UAEzB,OAAOC,MAAa,eACpB,OAAS,wBAAAC,MAA4B,UAUrC,IAAMC,EAAoEC,GACxE,IAAI,QAAQ,CAACC,EAASC,IAAW,CAC/B,IAAIC,EAAO,GACXH,EAAS,GAAG,OAASI,GAAWD,GAAQC,CAAM,EAC9CJ,EAAS,GAAG,MAAO,IAAMC,EAAQE,CAAI,CAAC,EACtCH,EAAS,GAAG,QAAUK,GAAQH,EAAOG,CAAG,CAAC,CAC3C,CAAC,EAEIC,EAAQ,CAACC,EAAqBC,IAAyC,CAC5E,IAAMC,EAAQ,OAAOD,GAAY,SAAWA,EAAUA,GAAS,MAAQ,MACjEE,EAAc,OAAOF,GAAY,UAAYA,GAAS,UAAY,OAAYA,EAAQ,QAAU,GAEhGG,EAAOC,GAAoB,CAC/B,QAAQ,IAAIF,GAAe,CAACb,EAAQ,UAAY,IAAIA,EAAQ,QAAQ,IAAM,KAAK,MAAMA,EAAQ,QAAQ,SAAS,KAAO,KAAK,KAAKe,CAAO,GAAKA,CAAO,CACpJ,EAEA,GAAIF,GAAeb,EAAQ,UAAW,CACpCc,EAAI,+CAA+C,EAEnD,QAASE,EAAI,EAAGA,EAAIf,EAAqB,EAAGe,IAC1ChB,EAAQ,KAAK,EAGf,MACF,CAEA,IAAMiB,EAAuC,CAC3C,UAAW,UAAa,CAAE,OAAQ,KAAM,UAAW,KAAK,IAAI,CAAE,GAC9D,YAAa,IAAc,OAAK,EAChC,UAAW,MAAOC,GAAYR,EAAO,KAAK,MAAM,MAAMR,EAAiBgB,CAAO,CAAC,CAAC,EAChF,OAAQ,UAAa,CAAE,OAAQ,YAAa,UAAW,KAAK,IAAI,CAAE,EACpE,EAEApB,EAAa,MAAOoB,EAASC,IAAa,CACxC,IAAMC,EAAgBH,EAAeC,EAAQ,GAAG,GAAKD,EAAO,MAAM,EAElE,GAAI,CACFE,EAAS,UAAU,IAAK,CAAE,eAAgB,mBAAoB,OAAQ,gBAAiB,CAAC,EACxFA,EAAS,MAAM,KAAK,UAAU,MAAMC,EAAcF,CAAO,CAAC,CAAC,CAC7D,OAASG,EAAG,CACV,QAAQ,MAAMA,CAAC,CACjB,CAEAF,EAAS,IAAI,CACf,CAAC,EAAE,OAAOP,EAAO,IAAME,EAAI,6BAA6B,CAAC,EAEzDA,EAAI,+BAA+BF,CAAK,KAAK,CAC/C",
  "names": ["createServer", "process", "cluster", "availableParallelism", "readableToString", "readable", "resolve", "reject", "data", "chunk", "err", "server_default", "render", "options", "_port", "_useCluster", "log", "message", "i", "routes", "request", "response", "dispatchRoute", "e"]
}
