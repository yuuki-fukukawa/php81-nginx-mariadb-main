{
  "version": 3,
  "sources": ["../src/server.ts"],
  "sourcesContent": ["import { createServer, IncomingMessage } from 'http'\nimport * as process from 'process'\nimport { InertiaAppResponse, Page } from './types'\nimport cluster from 'node:cluster';\nimport { availableParallelism } from 'node:os';\n\ntype AppCallback = (page: Page) => InertiaAppResponse\ntype RouteHandler = (request: IncomingMessage) => Promise<unknown>\ntype ServerOptions = {\n  port?: number\n  cluster?: boolean\n}\ntype Port = number\n\nconst readableToString: (readable: IncomingMessage) => Promise<string> = (readable) =>\n  new Promise((resolve, reject) => {\n    let data = ''\n    readable.on('data', (chunk) => (data += chunk))\n    readable.on('end', () => resolve(data))\n    readable.on('error', (err) => reject(err))\n  })\n\nexport default (render: AppCallback, options?: Port | ServerOptions): void => {\n  const _port = typeof options === 'number' ? options : options?.port ?? 13714;\n  const _useCluster = typeof options === 'object' && options?.cluster !== undefined ? options.cluster : false;\n\n  const log = (message: string) => {\n    console.log(_useCluster && !cluster.isPrimary ? `[${cluster.worker?.id ?? 'N/A'} / ${cluster.worker?.process?.pid ?? 'N/A'}] ${message}` : message)\n  }\n\n  if (_useCluster && cluster.isPrimary) {\n    log('Primary Inertia SSR server process started...')\n\n    for (let i = 0; i < availableParallelism(); i++) {\n      cluster.fork()\n    }\n\n    return\n  }\n\n  const routes: Record<string, RouteHandler> = {\n    '/health': async () => ({ status: 'OK', timestamp: Date.now() }),\n    '/shutdown': () => process.exit(),\n    '/render': async (request) => render(JSON.parse(await readableToString(request))),\n    '/404': async () => ({ status: 'NOT_FOUND', timestamp: Date.now() }),\n  }\n\n  createServer(async (request, response) => {\n    const dispatchRoute = routes[<string>request.url] || routes['/404']\n\n    try {\n      response.writeHead(200, { 'Content-Type': 'application/json', Server: 'Inertia.js SSR' })\n      response.write(JSON.stringify(await dispatchRoute(request)))\n    } catch (e) {\n      console.error(e)\n    }\n\n    response.end()\n  }).listen(_port, () => log('Inertia SSR server started.'))\n\n  log(`Starting SSR server on port ${_port}...`)\n}\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAA8C,gBAC9CC,EAAyB,wBAEzBC,EAAoB,6BACpBC,EAAqC,mBAU/BC,EAAoEC,GACxE,IAAI,QAAQ,CAACC,EAASC,IAAW,CAC/B,IAAIC,EAAO,GACXH,EAAS,GAAG,OAASI,GAAWD,GAAQC,CAAM,EAC9CJ,EAAS,GAAG,MAAO,IAAMC,EAAQE,CAAI,CAAC,EACtCH,EAAS,GAAG,QAAUK,GAAQH,EAAOG,CAAG,CAAC,CAC3C,CAAC,EAEIZ,EAAQ,CAACa,EAAqBC,IAAyC,CAC5E,IAAMC,EAAQ,OAAOD,GAAY,SAAWA,EAAUA,GAAS,MAAQ,MACjEE,EAAc,OAAOF,GAAY,UAAYA,GAAS,UAAY,OAAYA,EAAQ,QAAU,GAEhGG,EAAOC,GAAoB,CAC/B,QAAQ,IAAIF,GAAe,CAAC,EAAAG,QAAQ,UAAY,IAAI,EAAAA,QAAQ,QAAQ,IAAM,KAAK,MAAM,EAAAA,QAAQ,QAAQ,SAAS,KAAO,KAAK,KAAKD,CAAO,GAAKA,CAAO,CACpJ,EAEA,GAAIF,GAAe,EAAAG,QAAQ,UAAW,CACpCF,EAAI,+CAA+C,EAEnD,QAASG,EAAI,EAAGA,KAAI,wBAAqB,EAAGA,IAC1C,EAAAD,QAAQ,KAAK,EAGf,MACF,CAEA,IAAME,EAAuC,CAC3C,UAAW,UAAa,CAAE,OAAQ,KAAM,UAAW,KAAK,IAAI,CAAE,GAC9D,YAAa,IAAc,OAAK,EAChC,UAAW,MAAOC,GAAYT,EAAO,KAAK,MAAM,MAAMP,EAAiBgB,CAAO,CAAC,CAAC,EAChF,OAAQ,UAAa,CAAE,OAAQ,YAAa,UAAW,KAAK,IAAI,CAAE,EACpE,KAEA,gBAAa,MAAOA,EAASC,IAAa,CACxC,IAAMC,EAAgBH,EAAeC,EAAQ,GAAG,GAAKD,EAAO,MAAM,EAElE,GAAI,CACFE,EAAS,UAAU,IAAK,CAAE,eAAgB,mBAAoB,OAAQ,gBAAiB,CAAC,EACxFA,EAAS,MAAM,KAAK,UAAU,MAAMC,EAAcF,CAAO,CAAC,CAAC,CAC7D,OAASG,EAAG,CACV,QAAQ,MAAMA,CAAC,CACjB,CAEAF,EAAS,IAAI,CACf,CAAC,EAAE,OAAOR,EAAO,IAAME,EAAI,6BAA6B,CAAC,EAEzDA,EAAI,+BAA+BF,CAAK,KAAK,CAC/C",
  "names": ["server_exports", "__export", "server_default", "__toCommonJS", "import_http", "process", "import_node_cluster", "import_node_os", "readableToString", "readable", "resolve", "reject", "data", "chunk", "err", "render", "options", "_port", "_useCluster", "log", "message", "cluster", "i", "routes", "request", "response", "dispatchRoute", "e"]
}
